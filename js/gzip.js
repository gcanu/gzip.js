// Generated by CoffeeScript 1.6.2
(function() {
  window.decompress = function(cText) {
    var b, block, blockHeader, cm, code, codes, defCodeLengths, endofblock, filename, flg, getBitsSequence, getFileHeader, getHeader, getHuffmanCodes, getNextCode, getNextDynamicCode, i, id1, id2, mtime, os, readCompressedBlock, readFileName, text, xfl, _i, _j, _k, _l;

    id1 = id2 = cm = flg = mtime = xfl = os = filename = null;
    text = "";
    b = 0;
    getFileHeader = function() {
      id1 = getBitsSequence(8, true);
      id2 = getBitsSequence(8, true);
      cm = getBitsSequence(8, true);
      flg = getBitsSequence(8, true);
      mtime = getBitsSequence(32, true);
      xfl = getBitsSequence(8, true);
      os = getBitsSequence(8, true);
      return filename = readFileName();
    };
    getHeader = function() {
      var bfinal, btype;

      bfinal = getBitsSequence(1);
      btype = (getBitsSequence(1)) | ((getBitsSequence(1)) << 1);
      return {
        bfinal: bfinal,
        btype: btype
      };
    };
    readFileName = function() {
      var car, str;

      str = "";
      car = 1;
      while (car !== 0) {
        car = getBitsSequence(8, true);
        str += String.fromCharCode(car);
      }
      return str;
    };
    getHuffmanCodes = function(cl) {
      var a, bits, bl_count, code, el, hcodes, i, len, maxCodeLength, minCodeLength, next_code, value, _i, _j, _k, _l, _len, _len1, _len2, _ref;

      if (cl === null || cl === void 0) {
        return null;
      }
      minCodeLength = 7777;
      maxCodeLength = 0;
      a = [];
      for (i = _i = 0, _len = cl.length; _i < _len; i = ++_i) {
        el = cl[i];
        if (el > 0) {
          a[i] = el;
        }
      }
      bl_count = [];
      for (_j = 0, _len1 = a.length; _j < _len1; _j++) {
        el = a[_j];
        if (bl_count[el] === void 0) {
          bl_count[el] = 0;
        }
        bl_count[el]++;
        if (el < minCodeLength) {
          minCodeLength = el;
        }
        if (el > maxCodeLength) {
          maxCodeLength = el;
        }
      }
      code = 0;
      next_code = [];
      for (bits = _k = 1, _ref = bl_count.length - 1; 1 <= _ref ? _k <= _ref : _k >= _ref; bits = 1 <= _ref ? ++_k : --_k) {
        value = bl_count[bits - 1];
        if (value === void 0) {
          value = 0;
        }
        code = (code + value) << 1;
        next_code[bits] = code;
      }
      hcodes = {};
      for (i = _l = 0, _len2 = a.length; _l < _len2; i = ++_l) {
        el = a[i];
        if (el !== void 0) {
          len = el;
          if (len !== 0) {
            if (hcodes[len] === void 0) {
              hcodes[len] = [];
            }
            hcodes[len][i] = next_code[len];
            next_code[len]++;
          }
        }
      }
      hcodes["minCodeLength"] = minCodeLength;
      hcodes["maxCodeLength"] = maxCodeLength;
      return hcodes;
    };
    getBitsSequence = function(l, r) {
      var bit, getMask, i, o, seq, _i, _ref;

      if (l === 0) {
        return 0;
      }
      if (l > 32) {
        return null;
      }
      if (r === void 0) {
        r = false;
      }
      getMask = function(pos) {
        if ((0 <= pos && pos < 8)) {
          return Math.pow(2, pos);
        }
        return 0;
      };
      for (i = _i = 0, _ref = l - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        o = cText.charCodeAt(Math.floor(b / 8));
        bit = (o & getMask(b % 8)) >> (b % 8);
        if (r === false) {
          seq = (seq << 1) | bit;
        } else {
          seq |= bit << i;
        }
        b++;
      }
      return seq;
    };
    getNextCode = function(codes) {
      var code, l;

      l = codes.minCodeLength;
      while (l <= codes.maxCodeLength) {
        if (codes[l] !== null && codes[l] !== void 0) {
          code = codes[l].indexOf(getBitsSequence(l));
          if (code !== -1) {
            return code;
          } else {
            b -= l++;
          }
        } else {
          l++;
        }
      }
      return null;
    };
    getNextDynamicCode = function() {
      var alphabets, block, car, code, codeLengths, codes, distalph, hclen, hclens, hdist, hdistalph, hlit, hlitalph, i, litalph, prevcode, repeat, stext, subtext, _i, _j, _ref, _ref1;

      codeLengths = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      hlit = getBitsSequence(5, true) + 257;
      hdist = getBitsSequence(5, true) + 1;
      hclen = getBitsSequence(4, true) + 4;
      hclens = [];
      for (i = _i = 0, _ref = codeLengths.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i < hclen) {
          hclens[codeLengths[i]] = getBitsSequence(3, true);
        } else {
          hclens[codeLengths[i]] = 0;
        }
      }
      codes = getHuffmanCodes(hclens);
      repeat = function(code, times) {
        var tab, _j, _ref1;

        tab = [];
        for (i = _j = 0, _ref1 = times - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          tab.push(code);
        }
        return tab;
      };
      alphabets = [];
      while (alphabets.length < hlit + hdist) {
        code = getNextCode(codes);
        if (code === null) {
          return null;
        }
        if (code < 16) {
          alphabets.push(code);
        } else if (code === 16) {
          alphabets = alphabets.concat(repeat(prevcode, getBitsSequence(2, true) + 3));
        } else if (code === 17) {
          alphabets = alphabets.concat(repeat(0, getBitsSequence(3, true) + 3));
        } else if (code === 18) {
          alphabets = alphabets.concat(repeat(0, getBitsSequence(7, true) + 11));
        }
        prevcode = code;
      }
      hlitalph = alphabets.slice(0, hlit);
      hdistalph = alphabets.slice(-hdist);
      litalph = getHuffmanCodes(hlitalph);
      distalph = getHuffmanCodes(hdistalph);
      code = 0;
      car = "";
      subtext = "";
      while (code !== 256) {
        code = getNextCode(litalph);
        if (code === null) {
          return null;
        }
        if ((0 < code && code < 255)) {
          text += String.fromCharCode(code);
        } else if (code > 256) {
          block = readCompressedBlock(code, distalph);
          if (block === null) {
            return null;
          }
          if (block.dist >= block.len) {
            text += text.substr(text.length - block.dist, block.len);
          } else {
            stext = "";
            for (i = _j = 0, _ref1 = block.len - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
              stext += text.substr(text.length - block.dist + i % block.dist, 1);
            }
            text += stext;
          }
        }
      }
      return true;
    };
    readCompressedBlock = function(cb, distalph) {
      var dist, distCode, getEBDist, getEBLen, getMinDistance, getMinLen, len;

      if ((285 < cb && cb < 257)) {
        return null;
      }
      distalph = distalph || null;
      getEBLen = function(n) {
        if (n > 264) {
          return Math.ceil((n - 264) / 4);
        } else {
          return 0;
        }
      };
      getEBDist = function(n) {
        if (n > 3) {
          return Math.ceil((n - 3) / 2);
        } else {
          return 0;
        }
      };
      getMinLen = function(n) {
        if (n > 284) {
          return null;
        }
        if (n <= 264) {
          return 3 + (n - 257);
        } else {
          return getMinLen(n - 1) + (Math.pow(2, getEBLen(n - 1)));
        }
      };
      getMinDistance = function(n) {
        if ((29 < n && n < 0)) {
          return null;
        }
        if (n <= 3) {
          return n + 1;
        } else {
          return getMinDistance(n - 1) + (Math.pow(2, getEBDist(n - 1)));
        }
      };
      if (cb === 285) {
        len = 258;
      } else {
        len = getMinLen(cb) + (getBitsSequence(getEBLen(cb), true));
      }
      if (distalph === null) {
        distCode = getBitsSequence(5);
      } else {
        distCode = getNextCode(distalph);
        if (distCode === null) {
          return null;
        }
      }
      dist = getMinDistance(distCode) + (getBitsSequence(getEBDist(distCode), true));
      return {
        len: len,
        dist: dist
      };
    };
    getFileHeader();
    blockHeader = getHeader();
    endofblock = false;
    if (blockHeader.btype === 1) {
      defCodeLengths = [];
      for (i = _i = 0; _i <= 143; i = ++_i) {
        defCodeLengths.push(8);
      }
      for (i = _j = 144; _j <= 255; i = ++_j) {
        defCodeLengths.push(9);
      }
      for (i = _k = 256; _k <= 279; i = ++_k) {
        defCodeLengths.push(7);
      }
      for (i = _l = 280; _l <= 287; i = ++_l) {
        defCodeLengths.push(8);
      }
      codes = getHuffmanCodes(defCodeLengths);
      while (endofblock === false) {
        code = getNextCode(codes);
        if (distCode === null) {
          return null;
        }
        if (code < 256) {
          text += String.fromCharCode(code);
        } else if (code === 256) {
          endofblock = true;
        } else {
          block = readCompressedBlock(code);
          if (block === null) {
            return null;
          }
          text += text.substr(text.length - block.dist, block.len);
        }
      }
    } else if (blockHeader.btype === 2) {
      code = getNextDynamicCode();
      if (code === null) {
        return null;
      }
    }
    return text;
  };

}).call(this);
